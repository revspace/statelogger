#!/usr/bin/perl -w
use strict;
use autodie;
use Fcntl qw(SEEK_SET);
use POSIX qw(strftime round);
use Getopt::Long;

my $usage = "Usage: $0 [--all|--heatmap [--[no]hex]] [--unknown=ignore|open|closed|past|future]\n";

GetOptions(
    "all"       => \my $all,
    "days=i"    => \my $days,
    "heatmap"   => \my $heatmap,
    "hex"       => \my $hex,
    "unknown=s" => \(my $unknown_mode = "ignore"),
) or die $usage;

die $usage if $all and $heatmap;
die $usage if $hex and not $heatmap;
die $usage if @ARGV;

if ($heatmap and not defined $hex) {
    my ($rows, $columns) = split " ", `stty size 2>/dev/null`;
    $hex = $columns < 102 if $columns;
}

my $edges = $heatmap ? 0 : !$all;

my $fn = "/var/statelog";
my $header_length = 8;

open my $fh, "< :raw", $fn;
read($fh, my $start_time, $header_length) == $header_length or die "short read";

$start_time = unpack "q", $start_time;
my $now = time();
my $offset = 8;

if ($days) {
    my $first_time = time() - $days * 86400;
    die sprintf "Only %d days available.\n", int((time() - $start_time) / 86400)
        if $first_time < $start_time;
    $offset += int(($first_time - $start_time) / 60);
    seek $fh, $offset, SEEK_SET;
}

$/ = \1;  # make readline() read one 1 byte at a time.

sub while_data {
    my ($callback) = @_;

    my $last_known = undef;
    while (defined(my $value = readline $fh)) {
        my $count = 1;

        if ($value ne "0" and $value ne "1") {
            if ($unknown_mode eq 'ignore') {
                $value = undef;
            } elsif ($unknown_mode eq 'open') {
                $value = 1;
            } elsif ($unknown_mode eq 'closed') {
                $value = 0;
            } elsif ($unknown_mode eq 'past') {
                $value = $last_known;
            } elsif ($unknown_mode eq 'future') {
                LOOKAHEAD: while (defined($value = readline $fh)) {
                    $count++;
                    last LOOKAHEAD if $value eq "0" or $value eq "1";
                }
            } else {
                die "Unsupported mode '$unknown_mode'";
            }
        }

        if (defined $value) {
            for (1..$count) {
                if (not $edges or not(defined $last_known) or !$value != !$last_known) {
                    my $time = $start_time + ($offset - $header_length) * 60;
                    $callback->($time, $value)
                }
                $last_known = $value;
            }
        }
        $offset++;
    }
}

if ($heatmap) {
    my @open;    # [wday][hour]
    my @total;   # [wday][hour]
    while_data sub {
        my ($time, $value) = @_;

        my ($wday, $hour) = (localtime $time)[6, 2];
        $open[ $wday][$hour]++ if $value;
        $total[$wday][$hour]++;
    };

    printf(
        "   " . join("", ($hex ? " %x" : "%3d ") x 25). "\n",
        ($hex ? (0..11, 0..11, 0) : 0..24)
    );
    for my $wday (1, 2, 3, 4, 5, 6, 0) {
        printf(
            "%3s: " . join(" ", ($hex ? "%x" : "%3d") x 24) . "\n",
            (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
            map {
                $open[$wday][$_]
                ? round($open[$wday][$_] / $total[$wday][$_] * ($hex ? 10 : 100))
                : 0
            } 0..23
        );
    }
} else {
    printf(
        "Logging since %s.\n",
        strftime("%Y-%m-%d %H:%M:%S", localtime $start_time),
    );
    while_data sub {
        my ($time, $value) = @_;
        printf(
            "%s %s\n",
            strftime("%Y-%m-%d %H:%M", localtime $time),
            $value ? "open" : "closed",
        );
    };
}
