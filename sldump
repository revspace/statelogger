#!/usr/bin/perl -w
use strict;
use autodie;
use Fcntl qw(SEEK_SET);
use POSIX qw(strftime round ceil);
use Getopt::Long;

my $usage = "Usage: $0 [--all|--heatmap [--[no]hex] [--[no]color]] [--unknown=ignore|open|closed|past|future] [--days=n|--period=yyyy[-mm]]\n";

GetOptions(
    "all"       => \my $all,
    "days=i"    => \my $days,
    "period=s"  => \my $period,
    "heatmap"   => \my $heatmap,
    "hex!"      => \my $hex,
    "color!"    => \my $color,
    "unknown=s" => \(my $unknown_mode = "ignore"),
) or die $usage;

die $usage if $all and $heatmap;
die $usage if $hex and not $heatmap;
die $usage if $color and not $heatmap;
die $usage if $days and $period;
die $usage if $period and $period !~ /^\d\d\d\d(?:-\d\d)?$/;

if ($heatmap and not defined $hex) {
    my ($rows, $columns) = split " ", `stty size 2>/dev/null`;
    $hex = $columns < 102 if $columns;
}
if ($heatmap and not defined $color) {
    $color = -t STDOUT;
}

my $edges = $heatmap ? 0 : !$all;

sub color {
    my ($pct) = @_;
    my $bg = 232 + round($pct / 100 * 23);
    my $fg = $bg < 239 ? 242 : 0;
    return "\e[48;5;${bg}m\e[38;5;${fg}m";
}


my $fn = "/var/statelog";
my $header_length = 8;

open my $fh, "< :raw", $fn;
read($fh, my $start_time, $header_length) == $header_length or die "short read";

$start_time = unpack "q", $start_time;
my $now = time();
my $offset = 8;
my $last_time = undef;

if ($days) {
    my $first_time = time() - $days * 86400;
    die sprintf "Only %d days available.\n", int((time() - $start_time) / 86400)
        if $first_time < $start_time;
    $offset += int(($first_time - $start_time) / 60);
    
    printf "[%s - now]\n", strftime("%Y-%m-%d %H:%M:%S", localtime $first_time);
} elsif ($period) {
    my ($yyyy, $mm) = split /-/, $period;
    my $month = !!$mm;  # month or year
    $mm ||= 1;
    my $first_time = strftime "%s", 0, 0, 0, 1, $mm - 1, $yyyy - 1900;

    die sprintf "%s not available; logging since %s.\n",
        strftime("%Y-%m-%d %H:%M:%S", localtime $first_time),
        strftime("%Y-%m-%d %H:%M:%S", localtime $start_time)
        if $first_time < $start_time;

    for (1 .. ($month ? 1 : 12)) {
        $mm++;
        $yyyy++, $mm = 1 if $mm > 12;
    }
    $last_time = -1 + strftime "%s", 0, 0, 0, 1, $mm - 1, $yyyy - 1900;

    $offset += ceil(($first_time - $start_time) / 60);

    printf "[%s - %s]\n",
        strftime("%Y-%m-%d %H:%M:%S", localtime $first_time),
        strftime("%Y-%m-%d %H:%M:%S", localtime $last_time);
}

seek $fh, $offset, SEEK_SET;

$/ = \1;  # make readline() read one 1 byte at a time.

sub while_data {
    my ($callback) = @_;

    my $last_known = undef;
    while (defined(my $value = readline $fh)) {
        my $count = 1;

        if ($value ne "0" and $value ne "1") {
            if ($unknown_mode eq 'ignore') {
                $value = undef;
            } elsif ($unknown_mode eq 'open') {
                $value = 1;
            } elsif ($unknown_mode eq 'closed') {
                $value = 0;
            } elsif ($unknown_mode eq 'past') {
                $value = $last_known;
            } elsif ($unknown_mode eq 'future') {
                LOOKAHEAD: while (defined($value = readline $fh)) {
                    $count++;
                    last LOOKAHEAD if $value eq "0" or $value eq "1";
                }
            } else {
                die "Unsupported mode '$unknown_mode'";
            }
        }

        if (defined $value) {
            for (1..$count) {
                if (not $edges or not(defined $last_known) or !$value != !$last_known) {
                    my $time = $start_time + ($offset - $header_length) * 60;
                    return if $last_time and $time > $last_time;
                    $callback->($time, $value);
                }
                $last_known = $value;
            }
        }
        $offset++;
    }
}

if ($heatmap) {
    my @open;    # [wday][hour]
    my @total;   # [wday][hour]
    while_data sub {
        my ($time, $value) = @_;

        my ($wday, $hour) = (localtime $time)[6, 2];
        $open[ $wday][$hour]++ if $value;
        $total[$wday][$hour]++;
    };

    printf(
        "   " . join("", ($hex ? " %x" : "%3d ") x 25). "\n",
        ($hex ? (0..11, 0..11, 0) : 0..24)
    );
    for my $wday (1, 2, 3, 4, 5, 6, 0) {
        my @pct = map {
            $open[$wday][$_]
            ? round($open[$wday][$_] / $total[$wday][$_] * 100)
            : 0
        } 0..23;

        printf(
            "%3s: " . join(" ", ($hex ? "%s%x" : "%s%3d") x 24) . "%s\n",
            (qw(Sun Mon Tue Wed Thu Fri Sat))[$wday],
            (map {
                ($color ? color($_) : ""),
                ($hex ? round($_ / 10) : $_),
            } @pct),
            ($color ? "\e[0m" : ""),
        );
    }
    print "\n";
} else {
    printf(
        "Logging since %s.\n",
        strftime("%Y-%m-%d %H:%M:%S", localtime $start_time),
    );
    while_data sub {
        my ($time, $value) = @_;
        printf(
            "%s %s\n",
            strftime("%Y-%m-%d %H:%M", localtime $time),
            $value ? "open" : "closed",
        );
    };
}
